'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _createClass = require('@babel/runtime/helpers/createClass');
var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');
var _inherits = require('@babel/runtime/helpers/inherits');
var _wrapNativeSuper = require('@babel/runtime/helpers/wrapNativeSuper');
var parser = require('../../../../_virtual/parser.cjs');
require('./lexer.cjs');
var lexer = require('../../../../_virtual/lexer.cjs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);
var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);
var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
var _wrapNativeSuper__default = /*#__PURE__*/_interopDefaultLegacy(_wrapNativeSuper);

function _callSuper(_this, derived, args) {
  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    } catch (e) {
      return false;
    }
  }
  derived = _getPrototypeOf__default["default"](derived);
  return _possibleConstructorReturn__default["default"](_this, isNativeReflectConstruct() ? Reflect.construct(derived, args || [], _getPrototypeOf__default["default"](_this).constructor) : derived.apply(_this, args));
}
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * An AST parser for ICU MessageFormat strings
 *
 * @packageDocumentation
 * @example
 * ```
 * import { parse } from '@messageformat/parser
 *
 * parse('So {wow}.')
 * [ { type: 'content', value: 'So ' },
 *   { type: 'argument', arg: 'wow' },
 *   { type: 'content', value: '.' } ]
 *
 *
 * parse('Such { thing }. { count, selectordinal, one {First} two {Second}' +
 *       '                  few {Third} other {#th} } word.')
 * [ { type: 'content', value: 'Such ' },
 *   { type: 'argument', arg: 'thing' },
 *   { type: 'content', value: '. ' },
 *   { type: 'selectordinal',
 *     arg: 'count',
 *     cases: [
 *       { key: 'one', tokens: [ { type: 'content', value: 'First' } ] },
 *       { key: 'two', tokens: [ { type: 'content', value: 'Second' } ] },
 *       { key: 'few', tokens: [ { type: 'content', value: 'Third' } ] },
 *       { key: 'other',
 *         tokens: [ { type: 'octothorpe' }, { type: 'content', value: 'th' } ] }
 *     ] },
 *   { type: 'content', value: ' word.' } ]
 *
 *
 * parse('Many{type,select,plural{ numbers}selectordinal{ counting}' +
 *                          'select{ choices}other{ some {type}}}.')
 * [ { type: 'content', value: 'Many' },
 *   { type: 'select',
 *     arg: 'type',
 *     cases: [
 *       { key: 'plural', tokens: [ { type: 'content', value: 'numbers' } ] },
 *       { key: 'selectordinal', tokens: [ { type: 'content', value: 'counting' } ] },
 *       { key: 'select', tokens: [ { type: 'content', value: 'choices' } ] },
 *       { key: 'other',
 *         tokens: [ { type: 'content', value: 'some ' }, { type: 'argument', arg: 'type' } ] }
 *     ] },
 *   { type: 'content', value: '.' } ]
 *
 *
 * parse('{Such compliance')
 * // ParseError: invalid syntax at line 1 col 7:
 * //
 * //  {Such compliance
 * //        ^
 *
 *
 * const msg = '{words, plural, zero{No words} one{One word} other{# words}}'
 * parse(msg)
 * [ { type: 'plural',
 *     arg: 'words',
 *     cases: [
 *       { key: 'zero', tokens: [ { type: 'content', value: 'No words' } ] },
 *       { key: 'one', tokens: [ { type: 'content', value: 'One word' } ] },
 *       { key: 'other',
 *         tokens: [ { type: 'octothorpe' }, { type: 'content', value: ' words' } ] }
 *     ] } ]
 *
 *
 * parse(msg, { cardinal: [ 'one', 'other' ], ordinal: [ 'one', 'two', 'few', 'other' ] })
 * // ParseError: The plural case zero is not valid in this locale at line 1 col 17:
 * //
 * //   {words, plural, zero{
 * //                   ^
 * ```
 */
Object.defineProperty(parser.__exports, "__esModule", {
  value: true
});
exports.parse = parser.__exports.parse = parser.__exports.ParseError = void 0;
var lexer_js_1 = lexer.__exports;
var getContext = function getContext(lt) {
  return {
    offset: lt.offset,
    line: lt.line,
    col: lt.col,
    text: lt.text,
    lineBreaks: lt.lineBreaks
  };
};
var isSelectType = function isSelectType(type) {
  return type === 'plural' || type === 'select' || type === 'selectordinal';
};
function strictArgStyleParam(lt, param) {
  var value = '';
  var text = '';
  var _iterator = _createForOfIteratorHelper(param),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var p = _step.value;
      var pText = p.ctx.text;
      text += pText;
      switch (p.type) {
        case 'content':
          value += p.value;
          break;
        case 'argument':
        case 'function':
        case 'octothorpe':
          value += pText;
          break;
        default:
          throw new ParseError(lt, "Unsupported part in strict mode function arg style: ".concat(pText));
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var c = {
    type: 'content',
    value: value.trim(),
    ctx: Object.assign({}, param[0].ctx, {
      text: text
    })
  };
  return [c];
}
var strictArgTypes = ['number', 'date', 'time', 'spellout', 'ordinal', 'duration'];
var defaultPluralKeys = ['zero', 'one', 'two', 'few', 'many', 'other'];
/**
 * Thrown by {@link parse} on error
 *
 * @public
 */
var ParseError = /*#__PURE__*/function (_Error) {
  /** @internal */
  function ParseError(lt, msg) {
    _classCallCheck__default["default"](this, ParseError);
    return _callSuper(this, ParseError, [lexer_js_1.lexer.formatError(lt, msg)]);
  }
  _inherits__default["default"](ParseError, _Error);
  return _createClass__default["default"](ParseError);
}( /*#__PURE__*/_wrapNativeSuper__default["default"](Error));
parser.__exports.ParseError = ParseError;
var Parser = /*#__PURE__*/function () {
  function Parser(src, opt) {
    _classCallCheck__default["default"](this, Parser);
    var _a, _b, _c, _d;
    this.lexer = lexer_js_1.lexer.reset(src);
    this.cardinalKeys = (_a = opt === null || opt === void 0 ? void 0 : opt.cardinal) !== null && _a !== void 0 ? _a : defaultPluralKeys;
    this.ordinalKeys = (_b = opt === null || opt === void 0 ? void 0 : opt.ordinal) !== null && _b !== void 0 ? _b : defaultPluralKeys;
    this.strict = (_c = opt === null || opt === void 0 ? void 0 : opt.strict) !== null && _c !== void 0 ? _c : false;
    this.strictPluralKeys = (_d = opt === null || opt === void 0 ? void 0 : opt.strictPluralKeys) !== null && _d !== void 0 ? _d : true;
  }
  return _createClass__default["default"](Parser, [{
    key: "parse",
    value: function parse() {
      return this.parseBody(false, true);
    }
  }, {
    key: "checkSelectKey",
    value: function checkSelectKey(lt, type, key) {
      if (key[0] === '=') {
        if (type === 'select') throw new ParseError(lt, "The case ".concat(key, " is not valid with select"));
      } else if (type !== 'select') {
        var keys = type === 'plural' ? this.cardinalKeys : this.ordinalKeys;
        if (this.strictPluralKeys && keys.length > 0 && !keys.includes(key)) {
          var msg = "The ".concat(type, " case ").concat(key, " is not valid in this locale");
          throw new ParseError(lt, msg);
        }
      }
    }
  }, {
    key: "parseSelect",
    value: function parseSelect(_ref, inPlural, ctx, type) {
      var arg = _ref.value;
      var sel = {
        type: type,
        arg: arg,
        cases: [],
        ctx: ctx
      };
      if (type === 'plural' || type === 'selectordinal') inPlural = true;else if (this.strict) inPlural = false;
      var _iterator2 = _createForOfIteratorHelper(this.lexer),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var lt = _step2.value;
          switch (lt.type) {
            case 'offset':
              if (type === 'select') throw new ParseError(lt, 'Unexpected plural offset for select');
              if (sel.cases.length > 0) throw new ParseError(lt, 'Plural offset must be set before cases');
              sel.pluralOffset = Number(lt.value);
              ctx.text += lt.text;
              ctx.lineBreaks += lt.lineBreaks;
              break;
            case 'case':
              {
                this.checkSelectKey(lt, type, lt.value);
                sel.cases.push({
                  key: lt.value,
                  tokens: this.parseBody(inPlural),
                  ctx: getContext(lt)
                });
                break;
              }
            case 'end':
              return sel;
            /* istanbul ignore next: never happens */
            default:
              throw new ParseError(lt, "Unexpected lexer token: ".concat(lt.type));
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      throw new ParseError(null, 'Unexpected message end');
    }
  }, {
    key: "parseArgToken",
    value: function parseArgToken(lt, inPlural) {
      var ctx = getContext(lt);
      var argType = this.lexer.next();
      if (!argType) throw new ParseError(null, 'Unexpected message end');
      ctx.text += argType.text;
      ctx.lineBreaks += argType.lineBreaks;
      if (this.strict && (argType.type === 'func-simple' || argType.type === 'func-args') && !strictArgTypes.includes(argType.value)) {
        var msg = "Invalid strict mode function arg type: ".concat(argType.value);
        throw new ParseError(lt, msg);
      }
      switch (argType.type) {
        case 'end':
          return {
            type: 'argument',
            arg: lt.value,
            ctx: ctx
          };
        case 'func-simple':
          {
            var end = this.lexer.next();
            if (!end) throw new ParseError(null, 'Unexpected message end');
            /* istanbul ignore if: never happens */
            if (end.type !== 'end') throw new ParseError(end, "Unexpected lexer token: ".concat(end.type));
            ctx.text += end.text;
            if (isSelectType(argType.value.toLowerCase())) throw new ParseError(argType, "Invalid type identifier: ".concat(argType.value));
            return {
              type: 'function',
              arg: lt.value,
              key: argType.value,
              ctx: ctx
            };
          }
        case 'func-args':
          {
            if (isSelectType(argType.value.toLowerCase())) {
              var _msg = "Invalid type identifier: ".concat(argType.value);
              throw new ParseError(argType, _msg);
            }
            var param = this.parseBody(this.strict ? false : inPlural);
            if (this.strict && param.length > 0) param = strictArgStyleParam(lt, param);
            return {
              type: 'function',
              arg: lt.value,
              key: argType.value,
              param: param,
              ctx: ctx
            };
          }
        case 'select':
          /* istanbul ignore else: never happens */
          if (isSelectType(argType.value)) return this.parseSelect(lt, inPlural, ctx, argType.value);else throw new ParseError(argType, "Unexpected select type ".concat(argType.value));
        /* istanbul ignore next: never happens */
        default:
          throw new ParseError(argType, "Unexpected lexer token: ".concat(argType.type));
      }
    }
  }, {
    key: "parseBody",
    value: function parseBody(inPlural, atRoot) {
      var tokens = [];
      var content = null;
      var _iterator3 = _createForOfIteratorHelper(this.lexer),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var lt = _step3.value;
          if (lt.type === 'argument') {
            if (content) content = null;
            tokens.push(this.parseArgToken(lt, inPlural));
          } else if (lt.type === 'octothorpe' && inPlural) {
            if (content) content = null;
            tokens.push({
              type: 'octothorpe',
              ctx: getContext(lt)
            });
          } else if (lt.type === 'end' && !atRoot) {
            return tokens;
          } else {
            var value = lt.value;
            if (!inPlural && lt.type === 'quoted' && value[0] === '#') {
              if (value.includes('{')) {
                var errMsg = "Unsupported escape pattern: ".concat(value);
                throw new ParseError(lt, errMsg);
              }
              value = lt.text;
            }
            if (content) {
              content.value += value;
              content.ctx.text += lt.text;
              content.ctx.lineBreaks += lt.lineBreaks;
            } else {
              content = {
                type: 'content',
                value: value,
                ctx: getContext(lt)
              };
              tokens.push(content);
            }
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      if (atRoot) return tokens;
      throw new ParseError(null, 'Unexpected message end');
    }
  }]);
}();
/**
 * Parse an input string into an array of tokens
 *
 * @public
 * @remarks
 * The parser only supports the default `DOUBLE_OPTIONAL`
 * {@link http://www.icu-project.org/apiref/icu4c/messagepattern_8h.html#af6e0757e0eb81c980b01ee5d68a9978b | apostrophe mode}.
 */
function parse(src) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var parser = new Parser(src, options);
  return parser.parse();
}
exports.parse = parser.__exports.parse = parse;

exports["default"] = parser.__exports;
